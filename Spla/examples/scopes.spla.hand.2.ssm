// 
// (unit -> int) main = fun () {
//   int x = 3;
//   (int -> int) f = fun (y) {
//     return x + y;
//   };
//   return f(4);
// };
// 

// This version:
// - one frame per lexical scope (block/let)
//   - each frame consists of prevMP + vars
// - pull in function arguments


              ldc 0     // DUMMY old MP
              stmh 1    // create global frame
              str MP    // MP point to frame

              ldc 0     // unit arg for main()
              bsr _main // call main(())
              ajs -1

              ldr RR
              trap 0
              halt

__main:       ldr PC
              ldc 6
              add
              str RR
              ret

_main:        ldr MP    // prev MP
              lds -2    // arg
              ldc 0     // x
              ldc 0     // f
              stmh 4    // create main#0 frame
              ldc 3
              sub
              str MP    // MP point to frame

              ldc 3
              stl 2     // save in x
              bsr __main_f
              ldr RR    // get location of main.f code
              stl 3     // save in f

              ldc 4
              ldl 3     // get f
              jsr       // call f(4)
              ajs -1
              ldr RR
              str RR

              ldr MP
              ldh 0
              str MP     // restore old MP
              ret

__main_f:     ldr PC
              ldc 6
              add
              str RR
              ret

_main_f:      ldr MP    // prev MP
              lds -2    // arg y
              stmh 2    // create main.f#0 frame
              ldc 1
              sub
              str MP    // MP point to frame

              ldr MP
              ldh 0
              lda 2     // get x
              ldl 1     // get y
              add
              str RR

              ldr MP
              ldh 0
              str MP     // restore old MP
              ret