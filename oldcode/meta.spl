
type parser s a = s -> [(a, s)];
type char       = int;
type string     = [char];



var concat      ::  [t] -> [t] -> [t];
var concat_many :: [[t]]       -> [t];
var map         :: (a -> b) -> [a] -> [b];
var foldl       :: (a -> b -> a) -> a -> [b] -> a;

var mreturn     :: a -> parser s a;
var mbind       :: parser s a -> (a -> parser s b) -> parser s b;

var mzero       ::                               parser s a;
var mplus       ::  parser s a  -> parser s a -> parser s a;
var mplus_list  :: [parser s a]               -> parser s a;

var next        ::                parser [t] t;
var sat         :: (t -> bool) -> parser [t] t;
var element     ::  t          -> parser [t] t;

var digit       ::             parser string char;
var lower       ::             parser string char;
var upper       ::             parser string char;
var alpha       ::             parser string char;
var alphanum    ::             parser string char;
var pstring     ::  string  -> parser string string;
var pstring_any :: [string] -> parser string string;

var is          :: (int -> bool, int -> bool);
var is_even     ::  int -> bool;
var is_odd      ::               int -> bool;



is := (fun (n :: int) {
  if (n == 0) {
    return true;
  } else {
    return is.snd(n - 1);
  }
}, fun (n :: int) {
  if (n == 0) {
    return false;
  } else {
    return is.fst(n - 1);
  }
});
is_even := is.fst;
is_odd  := is.snd;




concat :=
  fun (a :: [t], b :: [t]) {
    if (empty(a)) {
      return b;
    } else {
      return a.hd : concat(a.tl, b);
    }
  };

concat_many :=
  fun (lists: [[t]]) {
    if (empty(lists)) {
      return [];
    } else {
      return concat(lists.hd, concat_many(lists.tl));
    }
  };

map :=
  fun (f :: a -> b, list :: [a]) {
    if (empty(list)) {
      return [];
    } else {
      return f(list.hd) : map(f, list.tl);
    }
  };

foldl :=
  fun (f :: a -> b -> a, e :: a, list :: [b]) {
    if (empty(list)) {
      return e;
    } else {
      return foldl(f, f(e, list.hd), list.tl);
    }
  };



mreturn :=
  fun (e :: a) {
    return fun (input :: s) {
      return (e, input) : [];
    };
  };

mbind :=
  fun (p :: parser s a, f :: a -> parser s b) {
    return fun (input :: s) {
      return concat_many(map(fun (r :: (a, s)) {
        var g :: parser s b;
        g := f(r.fst);
        return g(r.snd);
      }, p(input)));
    };
  };

mzero :=
  fun (input :: s) {
    return [];
  };

mplus :=
  fun (p :: parser s a, q :: parser s a, input :: s) {
    return concat(p(input), q(input));
  };

mplus_list :=
  fun (parsers :: [parser s a]) {
    return foldl(mplus, mzero, parsers);
  };



next :=
  fun (input :: [t]) {
    return (input.hd, input.tl) : [];
  };

sat :=
  fun (P :: t -> bool, input :: [t]) {
    if (P(input.hd)) {
      return next(input);
    } else {
      return [];
    }
  };

element :=
  fun (e1 :: t) {
    return sat(fun (e2 :: t) {
      return e1 == e2;
    });
  };



digit :=
  sat(fun (c :: char) {
    return c >= 48 && c <= 57;
  });

lower :=
  sat(fun (c :: char) {
    return c >= 97 && c <= 122;
  });

upper :=
  sat(fun (c :: char) {
    return c >= 65 && c <= 90;
  });

alpha :=
  mplus(lower, upper);

alphanum :=
  mplus(alpha, digit);

pstring :=
  fun (match :: string) {
    if (empty(match)) {
      return mreturn([]);
    } else {
      return mbind(element(match.hd), fun (_ :: char) {
        return mbind(pstring(match.tl), fun (_ :: string) {
          return mreturn(match);
        });
      });
    }
  };

pstring_any :=
  fun (match_any :: [string]) {
    return mplus_list(map(pstring, match_any));
  };
